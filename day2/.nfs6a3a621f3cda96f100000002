#include <cassert>									#include <cassert>
#include <chrono>									#include <chrono>
#include <fstream>									#include <fstream>
#include <iostream>									#include <iostream>
#include <omp.h>									#include <omp.h>

										      >	#ifdef CRAYPAT
#include "pat_api.h"									#include "pat_api.h"
										      >	#endif
#include "utils.h"									#include "utils.h"

void updateHalo(Storage3D<double>& inField) {					      |	void updateHalo(Storage3D<double> &inField) {
  const int xInterior = inField.xMax() - inField.xMin();				  const int xInterior = inField.xMax() - inField.xMin();
  const int yInterior = inField.yMax() - inField.yMin();				  const int yInterior = inField.yMax() - inField.yMin();

  // bottom edge (without corners)							  // bottom edge (without corners)
  for(std::size_t k = 0; k < inField.zMin(); ++k) {				      |	  for (std::size_t k = 0; k < inField.zMin(); ++k) {
    for(std::size_t j = 0; j < inField.yMin(); ++j) {				      |	    for (std::size_t j = 0; j < inField.yMin(); ++j) {
      for(std::size_t i = inField.xMin(); i < inField.xMax(); ++i) {		      |	      for (std::size_t i = inField.xMin(); i < inField.xMax(); ++i) {
        inField(i, j, k) = inField(i, j + yInterior, k);				        inField(i, j, k) = inField(i, j + yInterior, k);
      }											      }
    }											    }
  }											  }

  // top edge (without corners)								  // top edge (without corners)
  for(std::size_t k = 0; k < inField.zMin(); ++k) {				      |	  for (std::size_t k = 0; k < inField.zMin(); ++k) {
    for(std::size_t j = inField.yMax(); j < inField.ySize(); ++j) {		      |	    for (std::size_t j = inField.yMax(); j < inField.ySize(); ++j) {
      for(std::size_t i = inField.xMin(); i < inField.xMax(); ++i) {		      |	      for (std::size_t i = inField.xMin(); i < inField.xMax(); ++i) {
        inField(i, j, k) = inField(i, j - yInterior, k);				        inField(i, j, k) = inField(i, j - yInterior, k);
      }											      }
    }											    }
  }											  }

  // left edge (including corners)							  // left edge (including corners)
  for(std::size_t k = 0; k < inField.zMin(); ++k) {				      |	  for (std::size_t k = 0; k < inField.zMin(); ++k) {
    for(std::size_t j = inField.yMin(); j < inField.yMax(); ++j) {		      |	    for (std::size_t j = inField.yMin(); j < inField.yMax(); ++j) {
      for(std::size_t i = 0; i < inField.xMin(); ++i) {				      |	      for (std::size_t i = 0; i < inField.xMin(); ++i) {
        inField(i, j, k) = inField(i + xInterior, j, k);				        inField(i, j, k) = inField(i + xInterior, j, k);
      }											      }
    }											    }
  }											  }

  // right edge (including corners)							  // right edge (including corners)
  for(std::size_t k = 0; k < inField.zMin(); ++k) {				      |	  for (std::size_t k = 0; k < inField.zMin(); ++k) {
    for(std::size_t j = inField.yMin(); j < inField.yMax(); ++j) {		      |	    for (std::size_t j = inField.yMin(); j < inField.yMax(); ++j) {
      for(std::size_t i = inField.xMax(); i < inField.xSize(); ++i) {		      |	      for (std::size_t i = inField.xMax(); i < inField.xSize(); ++i) {
        inField(i, j, k) = inField(i - xInterior, j, k);				        inField(i, j, k) = inField(i - xInterior, j, k);
      }											      }
    }											    }
  }											  }
}											}

void apply_diffusion(Storage3D<double>& inField, Storage3D<double>& outField, double  |	void apply_diffusion(Storage3D<double> &inField, Storage3D<double> &outField,
                     unsigned numIter, int x, int y, int z, int halo) {		      |	                     double alpha, unsigned numIter, int x, int y, int z,
										      >	                     int halo) {

  Storage3D<double> tmp1Field(x, y, z, halo);						  Storage3D<double> tmp1Field(x, y, z, halo);

  for(std::size_t iter = 0; iter < numIter; ++iter) {				      |	  for (std::size_t iter = 0; iter < numIter; ++iter) {

    updateHalo(inField);								    updateHalo(inField);
										      |	    double a1 = -1. * alpha;
    for(std::size_t k = 0; k < inField.zMax(); ++k) {				      |	    double a2 = -2. * alpha;
										      |	    double a8 = 8. * alpha;
      // apply the computation							      |	    double a20 = 1. - 20. * alpha;
      for(/* loopbounds here */;;) {						      |
        for(/* loopbounds here */;;) {						      |	    for (std::size_t k = 0; k < inField.zMax(); ++k) {
          // implementation here...						      |
										      >	      // apply the full diffusion
										      >	#pragma omp parallel for
										      >	      for (std::size_t j = inField.yMin(); j < inField.yMax(); ++j) {
										      >	        for (std::size_t i = inField.xMin(); i < inField.xMax(); ++i) {
										      >	          outField(i, j, k) =
										      >	              a1 * inField(i, j - 2, k) + a2 * inField(i - 1, j - 1, k) +
										      >	              a8 * inField(i, j - 1, k) + a2 * inField(i + 1, j - 1, k) +
										      >	              a1 * inField(i - 2, j, k) + a8 * inField(i - 1, j, k) +
										      >	              a20 * inField(i, j, k) + a8 * inField(i + 1, j, k) +
										      >	              a1 * inField(i + 2, j, k) + a2 * inField(i - 1, j + 1, k) +
										      >	              a8 * inField(i, j + 1, k) + a2 * inField(i + 1, j + 1, k) +
										      >	              a1 * inField(i, j + 2, k);
        }										        }
      }											      }

      // update the field								      // update the field
      for(std::size_t j = inField.yMin(); j < inField.yMax(); ++j) {		      |	#pragma omp parallel for
        for(std::size_t i = inField.xMin(); i < inField.xMax(); ++i) {		      |	      for (std::size_t j = inField.yMin(); j < inField.yMax(); ++j) {
          if(iter != numIter - 1) {						      |	        for (std::size_t i = inField.xMin(); i < inField.xMax(); ++i) {
            inField(i, j, k) = 0; // one variable here...			      |	          if (iter != numIter - 1) {
										      >	            inField(i, j, k) = outField(i, j, k);
          }										          }
        }										        }
      }											      }
    }											    }
  }											  }
}											}

void reportTime(const Storage3D<double>& storage, int nIter, double diff) {	      |	void reportTime(const Storage3D<double> &storage, int nIter, double diff) {
  std::cout << "# ranks nx ny ny nz num_iter time\ndata = np.array( [ \\\n";		  std::cout << "# ranks nx ny ny nz num_iter time\ndata = np.array( [ \\\n";
  int size;										  int size;
#pragma omp parallel									#pragma omp parallel
  {											  {
#pragma omp master									#pragma omp master
    { size = omp_get_num_threads(); }							    { size = omp_get_num_threads(); }
  }											  }
  std::cout << "[ " << size << ", " << storage.xMax() - storage.xMin() << ", "		  std::cout << "[ " << size << ", " << storage.xMax() - storage.xMin() << ", "
            << storage.yMax() - storage.yMin() << ", " << storage.zMax() << ", " << n |	            << storage.yMax() - storage.yMin() << ", " << storage.zMax() << ", "
            << diff << "],\n";							      |	            << nIter << ", " << diff << "],\n";
  std::cout << "] )" << std::endl;							  std::cout << "] )" << std::endl;
}											}

int main(int argc, char const* argv[]) {					      |	int main(int argc, char const *argv[]) {
#ifdef CRAYPAT										#ifdef CRAYPAT
  PAT_record(PAT_STATE_OFF);								  PAT_record(PAT_STATE_OFF);
#endif											#endif
  int x = atoi(argv[2]);								  int x = atoi(argv[2]);
  int y = atoi(argv[4]);								  int y = atoi(argv[4]);
  int z = atoi(argv[6]);								  int z = atoi(argv[6]);
  int iter = atoi(argv[8]);								  int iter = atoi(argv[8]);
  int nHalo = 3;									  int nHalo = 3;
  assert(x > 0 && y > 0 && z > 0 && iter > 0);						  assert(x > 0 && y > 0 && z > 0 && iter > 0);
  Storage3D<double> input(x, y, z, nHalo);						  Storage3D<double> input(x, y, z, nHalo);
  input.initialize();									  input.initialize();
  Storage3D<double> output(x, y, z, nHalo);						  Storage3D<double> output(x, y, z, nHalo);
  output.initialize();									  output.initialize();

  double alpha = 1. / 32.;								  double alpha = 1. / 32.;

  std::ofstream fout;									  std::ofstream fout;
  fout.open("in_field.dat", std::ios::binary | std::ofstream::trunc);			  fout.open("in_field.dat", std::ios::binary | std::ofstream::trunc);
  input.writeFile(fout);								  input.writeFile(fout);
  fout.close();										  fout.close();
#ifdef CRAYPAT										#ifdef CRAYPAT
  PAT_record(PAT_STATE_ON);								  PAT_record(PAT_STATE_ON);
#endif											#endif
  auto start = std::chrono::steady_clock::now();					  auto start = std::chrono::steady_clock::now();

  apply_diffusion(input, output, alpha, iter, x, y, z, nHalo);				  apply_diffusion(input, output, alpha, iter, x, y, z, nHalo);

  auto end = std::chrono::steady_clock::now();						  auto end = std::chrono::steady_clock::now();
#ifdef CRAYPAT										#ifdef CRAYPAT
  PAT_record(PAT_STATE_OFF);								  PAT_record(PAT_STATE_OFF);
#endif											#endif
  updateHalo(output);									  updateHalo(output);
  fout.open("out_field.dat", std::ios::binary | std::ofstream::trunc);			  fout.open("out_field.dat", std::ios::binary | std::ofstream::trunc);
  output.writeFile(fout);								  output.writeFile(fout);
  fout.close();										  fout.close();

  auto diff = end - start;								  auto diff = end - start;
  double timeDiff = std::chrono::duration<double, std::milli>(diff).count() / 1000.;  |	  double timeDiff =
										      >	      std::chrono::duration<double, std::milli>(diff).count() / 1000.;
  reportTime(output, iter, timeDiff);							  reportTime(output, iter, timeDiff);

  return 0;										  return 0;
}											}